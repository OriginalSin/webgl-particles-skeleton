<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<script src="http://threejs.org/build/three.min.js"></script>

		<script src="./main.js"></script>
		
		<style>
			* {
				margin: 0px;
				padding: 0px;
			}

			body {
				overflow: hidden;
				background-color: #1a1a1a;
			}

			.hidden {display: none;}
		</style>
	</head>
	<body>
		<div id="container"> </div>

		<!-- TODO: Legg dette i glsl-filer og bygg -->
		<script type="x-shader/x-vertex" id="vertexshader"> 
			uniform float time;
			uniform float nofParticles;
			uniform float particleSize;
			uniform float pixelRatio;

			varying vec3 particlePosition;

			attribute float vertexIndex;
			attribute vec4 deviance;

			float easeOutCubic(float t) {
				t--;
				return t*t*t + 1.0;
			}

			float easeInOutCubic(float t) {
				if (t < 0.5) 
					return 4.0*t*t*t;
				else 
					return (t-1.0)*(2.0*t-2.0)*(2.0*t-2.0)+1.0;
			}

			vec3 targetPosition() {
				float width = 30.0;
				float z = -width/2.0;
				if (deviance.y < 0.1) z -= 50.0;
				if (deviance.y > 0.4) z += 50.0;

				return vec3(-20.0, 60.0 + deviance.w*10.0, z + deviance.z*width);
			}

			void main() {
				float square = floor(sqrt(nofParticles));

				float x = mod(vertexIndex, square);
				float y = floor(vertexIndex / square);

				vec3 gridPosition = vec3(x - square/2.0, 0, y - square/2.0);

				vec3 startPosition = vec3(gridPosition.x, gridPosition.y + sin(gridPosition.z/2.0 + time*3.0), gridPosition.z);
				
				vec3 targetPosition = targetPosition();

				float speed = 1.0/2.0;
				float relativeTime = clamp((time - deviance.x*10.0)*speed, 0.0, 1.0);

				vec3 newPosition = mix(startPosition, targetPosition, easeInOutCubic(relativeTime));

				particlePosition = newPosition;

				vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);
    			gl_PointSize = particleSize/length(mvPosition.xyz);

				gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
			}
		</script>
		<script type="x-shader/x-fragment" id="fragmentshader">
			uniform float time;

			varying vec3 particlePosition;

			vec4 circle(vec3 color, vec2 pointCoord) {
				float alpha;

				float gradient = 1.0 - length(pointCoord - vec2(0.5, 0.5));
				
				if (gradient > 0.5) // TODO: Use ternary
					alpha = 1.0; 
				else 
					alpha = 0.0;
				
				float gradientWidth = 0.1;
				if (gradient < 0.5 + gradientWidth && gradient > 0.5) 
					alpha = 1.0 - (0.5 + gradientWidth - gradient) / gradientWidth;

				return vec4(color.x, color.y, color.z, alpha);
			}

			void main() {
				vec3 white = vec3(1.0);
				gl_FragColor = circle(white, gl_PointCoord);
			}
		</script>

		<script type="text/javascript">
			HL.initAnimation("container", "renderer", 1.0);
			HL.animate();
		</script>
	</body>
</html>