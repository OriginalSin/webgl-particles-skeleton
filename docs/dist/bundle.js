!function(e){var r={};function n(t){if(r[t])return r[t].exports;var i=r[t]={i:t,l:!1,exports:{}};return e[t].call(i.exports,i,i.exports,n),i.l=!0,i.exports}n.m=e,n.c=r,n.d=function(e,r,t){n.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:t})},n.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},n.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(r,"a",r),r},n.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},n.p="",n(n.s=2)}([function(e,r){e.exports="#define PI 3.14159265358979323844\r\n\r\nuniform float time;\r\nuniform float nofParticles;\r\nuniform float particleSize;\r\nuniform float pixelRatio;\r\n\r\nvarying vec3 particlePosition;\r\nvarying vec4 devianceForFragshader;\r\n\r\nattribute float vertexIndex;\r\nattribute vec4 deviance;\r\n\r\nfloat easeOutCubic(float t) {\r\n  t--;\r\n  return t*t*t + 1.0;\r\n}\r\n\r\nfloat easeInOutCubic(float t) {\r\n  if (t < 0.5) \r\n    return 4.0*t*t*t;\r\n  else \r\n    return (t-1.0)*(2.0*t-2.0)*(2.0*t-2.0)+1.0;\r\n}\r\n\r\nfloat easeInOutQuad(float t) {\r\n  return t < 0.5 ? 2.0*t*t : -1.0+(4.0-2.0*t)*t;\r\n}\r\n\r\nvec2 get2DCoord(float index, float width) {\r\n  float x = mod(vertexIndex, width);\r\n  float y = floor(vertexIndex / width);\r\n\r\n  return vec2(x, y);\r\n}\r\n\r\nvec3 startPosition() {\r\n  float square = floor(sqrt(nofParticles));\r\n\r\n  vec2 coord2D = get2DCoord(vertexIndex, square) - vec2(square/2.0);\r\n\r\n  vec3 gridPosition = vec3(coord2D.x, 0, coord2D.y);\r\n\r\n  float wavelength = 1.0/10.0;\r\n  float wavespeed = 3.0;\r\n  float amplitude = 3.0;\r\n  float wave = amplitude * sin(gridPosition.z*wavelength + time*wavespeed);\r\n\r\n  return vec3(\r\n    gridPosition.x, \r\n    gridPosition.y + wave, \r\n    gridPosition.z\r\n  );\r\n}\r\n\r\nvec3 targetPosition() {\r\n  float width = 20.0;\r\n  float height = 40.0;\r\n  float z = -width/2.0;\r\n  if (deviance.y < 0.03) z -= width;\r\n  if (deviance.y > 0.2) z += width;\r\n\r\n  return vec3(-20.0, 30.0 + deviance.w*height, z + deviance.z*width);\r\n}\r\n\r\nvoid main() {\r\n\r\n  vec3 startPosition = startPosition();\r\n  \r\n  vec3 targetPosition = targetPosition();\r\n\r\n  float movementSpeed = 1.0/2.0;\r\n  float releaseTempo = 1.0/10.0;\r\n  float relativeTime = (time - deviance.x/releaseTempo) * movementSpeed;\r\n  relativeTime = clamp(relativeTime, 0.0, 1.0);\r\n\r\n  vec3 newPosition = mix(startPosition, targetPosition, easeInOutQuad(relativeTime));\r\n\r\n  particlePosition = newPosition;\r\n  devianceForFragshader = deviance;\r\n\r\n  vec4 mvPosition = modelViewMatrix * vec4(newPosition, 1.0);\r\n  \r\n  gl_PointSize = particleSize*pixelRatio/length(mvPosition.xyz);\r\n\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);\r\n}"},function(e,r){e.exports="uniform float time;\r\n\r\nvarying vec4 devianceForFragshader;\r\nvarying vec3 particlePosition;\r\n\r\nvec4 circle(vec3 color, vec2 pointCoord) {\r\n  float alpha;\r\n\r\n  float gradient = 1.0 - length(pointCoord - vec2(0.5, 0.5));\r\n  \r\n  if (gradient > 0.5) // TODO: Use ternary\r\n    alpha = 1.0; \r\n  else \r\n    alpha = 0.0;\r\n  \r\n  float gradientWidth = 0.1;\r\n  if (gradient < 0.5 + gradientWidth && gradient > 0.5) \r\n    alpha = 1.0 - (0.5 + gradientWidth - gradient) / gradientWidth;\r\n\r\n  return vec4(color.x, color.y, color.z, alpha);\r\n}\r\n\r\nvoid main() {\r\n  vec3 white = vec3(1.0);\r\n  vec3 green = vec3(0.5, 1.0, 0.5);\r\n  vec3 red = vec3(1.0, 0.25, 0.25);\r\n\r\n  vec3 color = white;\r\n  if (devianceForFragshader.y < 0.03) color = green;\r\n  if (devianceForFragshader.y > 0.2) color = red;\r\n\r\n  gl_FragColor = circle(color, gl_PointCoord);\r\n}"},function(e,r,n){"use strict";n.r(r);var t=n(1),i=n.n(t),o=n(0),a=n.n(o);const l=4e4;let d,c,s,v;const f={time:{value:0},pixelRatio:{value:window.devicePixelRatio},nofParticles:{value:l},particleSize:{value:window.screen.width/4}};const u=function(){requestAnimationFrame(u),f.time.value=((new Date).getTime()-d)/1e3,s.render(v,c)};(function(e,r){d=(new Date).getTime(),(s=new THREE.WebGLRenderer({antialias:!1})).gammaInput=!0,s.gammaOutput=!0,s.setClearColor(1907997),s.domElement.setAttribute("id",r),s.setSize(window.innerWidth,window.innerHeight,!0),s.setPixelRatio(window.devicePixelRatio||1);const n=s.getContext().drawingBufferWidth/s.getContext().drawingBufferHeight;(c=new THREE.PerspectiveCamera(60,n,.1,1e4)).position.set(-150,50,0),c.lookAt(new THREE.Vector3(0,0,0)),c.updateProjectionMatrix(),document.getElementById(e).appendChild(s.domElement),v=new THREE.Scene;const t=function(){const e=new Float32Array(3*l),r=new THREE.BufferGeometry;r.addAttribute("position",new THREE.BufferAttribute(e,3));const n=new Float32Array(l);for(let e=0;e<n.length;e++)n[e]=e;r.addAttribute("vertexIndex",new THREE.BufferAttribute(n,1));const t=new Float32Array(4*l);for(let e=0;e<t.length;e++)t[e]=Math.random();return r.addAttribute("deviance",new THREE.BufferAttribute(t,4)),r.computeBoundingSphere(),r}(),o=new THREE.ShaderMaterial({uniforms:f,vertexShader:a.a,fragmentShader:i.a,transparent:!0}),u=new THREE.Points(t,o);v.add(u)})("container","renderer"),u()}]);